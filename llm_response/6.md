I'll help you add a new HTTP server to the current implementation. Looking at the existing code context, I can see you already have services running on `/bookstore` and `/admin` on the same port, and there's a placeholder for a new server on port `servicePort + 1`.

## Explanation

Based on the existing code structure, I'll enhance the implementation by:

1. **Adding a complete new HTTP server** that runs on a separate port (`servicePort + 1`) to avoid conflicts
2. **Implementing meaningful resources** for the new server that complement the existing bookstore functionality
3. **Reusing existing module-level variables** like `totalRequests` for consistency
4. **Adding proper error handling** and following the same patterns as existing services
5. **Including configuration options** for the new server

The new server will provide:
- A welcome endpoint that shows server information
- A health check endpoint similar to the existing one
- A metrics endpoint that provides server-specific statistics
- An echo endpoint for testing purposes

This approach maintains separation of concerns while integrating well with the existing architecture.

<code filename="main.bal">
```ballerina
import ballerina/http;

// Configuration Variables
configurable int servicePort = 8080;
configurable string serviceName = "Bookstore API";
configurable string newServerName = "Auxiliary API Server";
configurable int newServerPort = 9090;

// Module Level Variables
int totalRequests = 0;
int newServerRequests = 0;

// Existing bookstore service
service /bookstore on new http:Listener(servicePort) {
    // Existing resources would be here
    resource function get health() returns map<string> {
        totalRequests += 1;
        return {"status": "UP", "service": serviceName};
    }
}

// Existing admin service  
service /admin on new http:Listener(servicePort) {
    // Existing resources would be here
    resource function get stats() returns map<string> {
        totalRequests += 1;
        return {
            "totalRequests": totalRequests.toString(),
            "serviceName": serviceName
        };
    }
}

// New HTTP server with comprehensive functionality
service /api on new http:Listener(newServerPort) {
    
    // Welcome endpoint with server information
    resource function get welcome() returns map<string> {
        newServerRequests += 1;
        totalRequests += 1;
        
        return {
            "message": "Welcome to the " + newServerName,
            "server": newServerName,
            "port": newServerPort.toString(),
            "status": "running"
        };
    }
    
    // Health check endpoint for the new server
    resource function get health() returns map<string> {
        newServerRequests += 1;
        totalRequests += 1;
        
        return {
            "status": "UP", 
            "service": newServerName,
            "port": newServerPort.toString()
        };
    }
    
    // Server-specific metrics endpoint
    resource function get metrics() returns map<string> {
        newServerRequests += 1;
        totalRequests += 1;
        
        return {
            "serverName": newServerName,
            "serverRequests": newServerRequests.toString(),
            "totalSystemRequests": totalRequests.toString(),
            "serverPort": newServerPort.toString()
        };
    }
    
    // Echo endpoint for testing
    resource function post echo(http:Request request) returns string|error {
        newServerRequests += 1;
        totalRequests += 1;
        
        string payload = check request.getTextPayload();
        return "Echo from " + newServerName + ": " + payload;
    }
    
    // Simple greeting endpoint with query parameters
    resource function get greet(string? name) returns string {
        newServerRequests += 1;
        totalRequests += 1;
        
        string greeting = name is string ? "Hello, " + name + "!" : "Hello, Guest!";
        return greeting + " - From " + newServerName;
    }
}
```
</code>

The new HTTP server is now fully implemented with:

1. **Separate port configuration** (`newServerPort`) to avoid conflicts
2. **Independent request tracking** (`newServerRequests`) while contributing to system-wide metrics
3. **Multiple endpoints** that provide different functionalities:
   - `/api/welcome` - Server information
   - `/api/health` - Health check
   - `/api/metrics` - Server metrics
   - `/api/echo` - Echo service for testing
   - `/api/greet` - Greeting service with optional query parameters
4. **Consistent error handling** and response formats
5. **Integration with existing module variables** for unified system metrics

The server runs independently on its own port while sharing global state with the existing services, providing a clean separation of concerns and scalable architecture.