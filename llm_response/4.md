I'll extend the existing category service to support update (PUT) and delete (DELETE) operations for categories. Based on the existing code context, I can see there's already a service at `/admin` with POST and GET operations for categories. I'll add the new operations while maintaining consistency with the existing patterns.

The update operation will use a PUT method with the category ID as a path parameter, allowing clients to update existing categories. The delete operation will use a DELETE method, also with the category ID as a path parameter, to remove categories from the system. Both operations will include appropriate error handling for cases where the category doesn't exist, and the update operation will validate that the category name is not empty.

The implementation will maintain the existing request counting mechanism and use the same `bookCategories` map for data storage. The update operation will return appropriate HTTP status codes (200 OK for success, 404 Not Found if category doesn't exist, 400 Bad Request for validation errors), while the delete operation will return 204 No Content for successful deletion or 404 Not Found if the category doesn't exist.

<code filename="main.bal">
```ballerina
import ballerina/http;

public type BookCategory record {|
    string categoryId;
    string categoryName;
    string description;
|};

configurable int servicePort = 8080;
configurable string serviceName = "Bookstore API";

map<BookCategory> bookCategories = {};
int totalRequests = 0;

service /admin on new http:Listener(servicePort) {

    resource function post categories(@http:Payload BookCategory category) returns http:Created|http:BadRequest {
        totalRequests += 1;

        if category.categoryName.trim().length() == 0 {
            return http:BAD_REQUEST;
        }

        bookCategories[category.categoryId] = category;
        return http:CREATED;
    }

    resource function get categories() returns BookCategory[] {
        totalRequests += 1;
        return bookCategories.toArray();
    }

    resource function put categories/[string categoryId](@http:Payload BookCategory category) returns http:Ok|http:NotFound|http:BadRequest {
        totalRequests += 1;

        if !bookCategories.hasKey(categoryId) {
            return http:NOT_FOUND;
        }

        if category.categoryName.trim().length() == 0 {
            return http:BAD_REQUEST;
        }

        bookCategories[categoryId] = category;
        return http:OK;
    }

    resource function delete categories/[string categoryId]() returns http:NoContent|http:NotFound {
        totalRequests += 1;

        if !bookCategories.hasKey(categoryId) {
            return http:NOT_FOUND;
        }

        _ = bookCategories.remove(categoryId);
        return http:NO_CONTENT;
    }
}
```
</code>