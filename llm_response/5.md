Looking at the existing code, I can see that you already have an `ErrorResponse` type defined, but it uses `message` as the field name instead of `error` as requested in your query. I'll modify the code to standardize all error responses to use a JSON object with an `error` field, and ensure all resource functions return this standardized format consistently.

The main changes I'll make are:
1. Update the `ErrorResponse` type to use `error` as the field name instead of `message`
2. Ensure all error responses across all resource functions use this standardized format
3. Update the validation function to work with the new error response format
4. Add a missing service port configurable and a resource function to get all books

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/uuid;

// Service port configuration
configurable int servicePort = 8080;

// Error response type
public type ErrorResponse record {|
    string error;
|};

// Book record type
public type Book record {|
    string id;
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
|};

// Book creation request (without ID)
public type BookRequest record {|
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
|};

// In-memory storage for books
map<Book> bookStore = {};

service /bookstore on new http:Listener(servicePort) {
    
    // Get all books
    resource function get books() returns Book[]|ErrorResponse {
        Book[] allBooks = bookStore.toArray();
        return allBooks;
    }
    
    // Get a specific book by ID
    resource function get books/[string bookId]() returns Book|ErrorResponse {
        if bookStore.hasKey(k = bookId) {
            Book book = bookStore.get(k = bookId);
            return book;
        }
        return { error: "Book not found" };
    }

    // Create a new book
    resource function post books(@http:Payload BookRequest bookRequest) returns http:Created|ErrorResponse {
        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            string errorMessage = validatedBook.message();
            return { error: errorMessage };
        }

        bookStore[validatedBook.id] = validatedBook;
        return http:CREATED;
    }

    // Update an existing book
    resource function put books/[string bookId](@http:Payload BookRequest bookRequest) returns Book|ErrorResponse {
        if !bookStore.hasKey(k = bookId) {
            return { error: "Book not found" };
        }

        Book updatedBook = {
            id: bookId,
            title: bookRequest.title,
            author: bookRequest.author,
            isbn: bookRequest.isbn,
            price: bookRequest.price,
            quantity: bookRequest.quantity
        };

        bookStore[bookId] = updatedBook;
        return updatedBook;
    }

    // Delete a book
    resource function delete books/[string bookId]() returns http:NoContent|ErrorResponse {
        if !bookStore.hasKey(k = bookId) {
            return { error: "Book not found" };
        }

        _ = bookStore.remove(k = bookId);
        return http:NO_CONTENT;
    }
}

// Utility function to validate and format book data
function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    string trimmedTitle = bookRequest.title.trim();
    if trimmedTitle.length() == 0 {
        return error("Book title cannot be empty");
    }

    string trimmedAuthor = bookRequest.author.trim();
    if trimmedAuthor.length() == 0 {
        return error("Book author cannot be empty");
    }

    if bookRequest.price < 0.0d {
        return error("Book price cannot be negative");
    }

    if bookRequest.quantity < 0 {
        return error("Book quantity cannot be negative");
    }

    string bookId = uuid:createType1AsString();
    string trimmedIsbn = bookRequest.isbn.trim();

    Book validatedBook = {
        id: bookId,
        title: trimmedTitle,
        author: trimmedAuthor,
        isbn: trimmedIsbn,
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };

    return validatedBook;
}
```
</code>